# Pet-projects

The pet-projects are a great chance to gain hands-on experience when learning a programming language or libraries and/or frameworks. The pet-projects can also become a starting point for interviews and an invitation to dialogue if you start your career.

There are often difficulties with finding and choosing the idea of a pet-project. We tried to put together a small collection of links and ideas that can be a start for your inspiration. After reading it, you will be able to choose the most suitable idea or it will inspire you to some idea of your own!


## External links

* [Google Summer of Code](https://summerofcode.withgoogle.com/archive)

A collection of projects that were offered by various companies or the community as part of the annual student internship program from Google. The archive contains projects from the last few years. A large number of projects for the C++ language are presented. Perhaps you will find something interesting for yourself in the archive for practice, or try your hand at future internships.

* [Project based learning - C++](https://github.com/practical-tutorials/project-based-learning#cc)

The repository contains a collection of pet projects collected for various programming languages. Also includes an extensive list of ideas for C++.

* [Programming challenges](https://programming-challenges.jeremyjaydan.dev/) - [PNG изображение](https://programming-challenges.jeremyjaydan.dev/media/programming-challenges-v4.0.png)

Roulette with ideas for pet projects. You set up the expected complexity of the project and run the roulette. Then randomness will decide for you what task you will have to solve :)


## The list of pet-project ideas

### Games

Below is a list of classic video games that do not contain complex AI or dynamic world generation. You can implement one of the following games, and then refine additional functionality. As a graphics library, you can use [SFML](https://www.sfml-dev.org/). This is an easy-to-use library that provides a sufficient set of features for creating simple graphical interfaces for 2D or 2.5D games using [sprites](https://en.wikipedia.org/wiki/Sprite_(computer_graphics)). If you want to do something more complex where physics is applied, you can start with simple engines, for example: [Box2D](https://box2d.org/) or learn more advanced ones: [Cocos2D](https://www.cocos.com/en/), [Unreal Engine](https://www.unrealengine.com/en-US/) etc. Don't forget about the rule: "from simple to complex." Start with a simple one, and gradually increase the difficulty.

* [Snake](https://en.wikipedia.org/wiki/Snake_(video_game_genre))
* [Tetris](https://en.wikipedia.org/wiki/Tetris)
* [Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)
* [15 puzzle](https://en.wikipedia.org/wiki/15_puzzle)
* [Arkanoid](https://en.wikipedia.org/wiki/Arkanoid)
* [Minesweeper ](https://en.wikipedia.org/wiki/Minesweeper_(video_game))
* [2048](https://en.wikipedia.org/wiki/2048_(video_game))
* [Solitaire](https://en.wikipedia.org/wiki/Solitaire)
* [Spider Solitaire](https://en.wikipedia.org/wiki/Spider_(solitaire))
* [Ping-pong](https://en.wikipedia.org/wiki/Pong)
* [Donkey Kong](https://en.wikipedia.org/wiki/Donkey_Kong_(video_game))
* [Labyrinth](https://en.wikipedia.org/wiki/Labyrinth:_The_Computer_Game)
* [Network games for 2-4 players: ping-pong, poker, chess, battleships, etc.](https://en.wikipedia.org/wiki/Online_game)

It's recommended reading the following sources, which contain more information about various algorithms for gamedev. They can be useful for one of the above games, or for your own ideas:
* https://www.redblobgames.com/
* http://www.squidi.net/three/


---

### Applications

When creating an application, start with the simplest implementation of a console application. After each completed step, set a more complex task, for example: add a graphical interface for the application, teach the application to request data from the source using an http request, and then write/read the received data to a test file/database, etc. Do not forget about the principle: "from simple to complex."

* Network chat (raw sockets or using [gRPC](https://grpc.io/docs/languages/cpp/quickstart))
* Calculator
* File Manager
* Currency Converter
* Getting a list of "Pull-Requests" or "Issues" in any Github repository
* Routine automation: various calculations and generation of reports in the form of tables

--- 

### Student applications

The following examples are more suitable for students who are passing or recently passed basic disciplines: linear algebra, analytical geometry, mathematical analysis, physics, etc. Tasks for the application of the studied theory will help to simultaneously "catch two birds with one stone": to consolidate the studied theory in practice and to practice programming. This path is not closed to others, but it is obviously easier for students, because knowledge of academic disciplines is still fresh.

* Linear algebra library: matrices, vectors, calculations, etc.
* Modeling of various processes: physics, theoretical mechanics, etc.
* Application of numerical methods: integration, differentiation, approximation, interpolation, etc.