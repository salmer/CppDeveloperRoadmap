# Легенды и мифы про C++

## Язык C++ умер, на нем невозможно что-либо писать

Живее всех живых. 

На сегодняшний день находится в топах различных рейтингов языков программирования и даже набирает очки популярности, например: индекс [Tiobe](https://www.tiobe.com/tiobe-index/). Дурную славу "мертвого языка" он сыскал в нулевые годы, когда язык временно впал в анабиоз, а комитет стандартизации растворился во тьме. Но начиная со стандарта C++11, язык пережил ренессанс. Сегодня он активно продолжает пополняться и обновляться новым функционалом каждые три года. Многие проблемы, о которых заявляют свидетели "мертвого" C++ уже решены, но в силу того, что такие специалисты перестали вести разработку на C++, либо по верхам изучили его в ВУЗе/на курсах (наслушались баек от свидетелей "смерти"), то они продолжают порождать и сеять различные "мифы и легенды" о том, насколько C++ ужасен и страшен.


## "Настоящие программисты" начинают изучать C++ сразу под Linux/Vim/gcc

Если вышеперечисленная связка инструментов выглядит для вас малознакомой, то на данной стадии рекомендуем вам сконцентрироваться только на изучении основ языка C++. Мы также рекомендуем начать писать свои первые приложения в Microsoft Visual Studio IDE (подробнее см. [PreJunior Books](Books/PreJunior.md)).

Пойти по наиболее трудному пути выглядит пафосно, но есть высокая доля вероятности, что тот объем информации, который необходимо изучить для сборки "Hello World" в связке Linux + Vim + gcc , будет слишком большим. Это чревато быстрой демотивацией и разочарованием в программировании. Старайтесь идти по пути: от простого к сложному. В спортзале новички не пытаются поднять самую тяжелую штангу на первом занятии, т.к. знают, чем это может быть чревато. Это же правило работает и при обучении. Когда более-менее освоитесь с языком, то можете попробовать поиграться с написанием кода в любом дистрибутиве Linux. Но это уже совершенно другая история...


## Прежде чем учить C++ необходимо хорошо изучить C/Assembler/etc.

Нет, нет и ещё раз нет! 

Такое утверждение до сих пор живо из-за двух распространенных ситуаций: так учили в ВУЗе (Assembler -> C -> C++), либо от "старой гвардии" плюсовиков, т.к. они в своей практике проходили похожий путь. Современный C++ не требует подобного рода мучений. Этот язык автономен и может быть изучен без какого-либо бекграунда. Намного вероятнее, что при изучении в режиме "Си -> С++" у вас возникнет путаница в голове, а также устойчивое желание писать на C++ в стиле "Си с классами".


## Изучайте C++ по книге Страуструпа

Крайне вредный тезис, который пришел от "старогвардейцев", либо от тех, кто родился с клавиатурой в руках. 

Скорее всего этот совет произносят те, кто уже имел большой опыт разработки на других языках (C, Fortran, Delphi, и т.д.) и переходил с них на C++. Книга Страуструпа написана больше как справочник ([Язык программирования C++](https://www.ozon.ru/product/yazyk-programmirovaniya-c-spetsialnoe-izdanie-straustrup-bern-straustrup-bern-210215691)), потому и работать с ней требуется соответсвенно, но для этого уже надо хоть немного разбираться в языке. Лучше загляните в раздел [Книги](Books.md), там вы найдете книги для любого уровня владения языком.  


## Изучайте C++ только по стандарту

Тоже крайне снобисткий тезис. 

Во-первых, современный стандарт C++ уже превысил размер в 2000 страниц. Во-вторых, доступ к актуальной версии стандарта платный. И, в-третьих, стандарт написан не самым "дружелюбным" способом. Тем кто изучил язык по его стандарту можно пожать руку, но мы не рекомендуем так издеваться над собой. Опять же, лучше загляните в раздел [Книги](Books.md), там вы найдете книги для любого уровня владения языком. 


## Undefined Behavior преследует разработчика повсюду

Скорее нет, чем да.

Современный C++, а также инструментарий, возникший вокруг языка, позволяют избежать львиную долю проблем, связанных с неопределенным поведением. Здесь мы можем дать довольно простой совет: если сомневаетесь, что делает та или иная конструкция, то почитайте о ней на [CppReference](https://en.cppreference.com), [StackOverflow](https://stackoverflow.com/) или иных профильных порталах. Если после прочтения конструкция остается непонятной, то попробуйте переписать блок кода альтернативным и более простым способом, чтобы избежать неопредленного поведения. В простоте кроется великая сила!


## Нужно вручную управлять памятью, в языке нет сборщика мусора

Это байка также идет от "старогвардейцев", которые перестали писать на языке до появления стандарта C++11, либо от тех, кто поверхностно его изучал в ВУЗе без погружения в последние стандарты. Современный C++ имеет в составе своей библиотеки набор примитивов, который отвечает за  автоматическое выделение и освобождение памяти. Контроль за выделением памяти отошел на второй план. Во многих компаниях и командах вы также встретите правило: "не используйте сырых указателей". Опять же, не пренебрегайте современным инструментарием и санитайзерами. Они способны детектировать потенциальную утечку памяти ещё на этапе исходного кода.


## C++ - это сплошной легаси-код

Отчасти правдивый миф, но стоит отметить, что это применимо и к другим языкам. На самом современном стеке может производиться жуткое "легаси" руками разработчиков. Качество кода зависит от технической культуры команды и её визионеров, т.к. в большей степени легаcи-код порождается человеческим фактором: уровень разработчика и компетенций, отношение к работе, горящие сроки и т.п. На текущий момент на C++ разработано огромное количество систем, которые не первый год работают в режиме 24/7. Такие системы могли быть написаны в прошлом без соблюдения всевозможных практик разработки. Они часто являются основой бизнеса, которые приносят значительную часть прибыли. Потому проводить в таких системах масштабные изменения довольно рискованно. Разработчики работают с таким кодом предельно осторожно. Но не стоит думать, что с этим ничего не сделать. Постепенно такие системы переписываются с использованием современных практик и технологий. Такого рода задачи могут стать для вас не менее интересным вызовом, т.к. предоставляют отличную возможность освоить широкий спектр компетенций: чтение кода, реверс-инженеринг, написание тестов, проектирование архитектуры ПО, автоматизация, сбор требований и т.д.

---

[**На главную страницу**](README.md)